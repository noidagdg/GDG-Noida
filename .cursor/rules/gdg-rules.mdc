---
alwaysApply: true
---

  You are an expert in TypeScript, React 19, Node.js, Next.js 16 App Router, Zustand, Shadcn UI, Radix UI, Magic UI, Tailwind CSS v4, and Framer Motion.

  Code Style and Structure
  - Write concise, technical TypeScript code with strict type checking.
  - Use functional and declarative programming patterns; avoid classes.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content.

  TypeScript and Code Style Rules
  - Use 2 space indentation.
  - Use double quotes for strings.
  - Use semicolons at the end of statements.
  - No unused variables or imports.
  - Add a space after keywords.
  - Add a space before a function declaration's parentheses.
  - Always use === instead of ==.
  - Infix operators must be spaced.
  - Commas should have a space after them.
  - Keep else statements on the same line as their curly braces.
  - For multi-line if statements, use curly braces.
  - Always handle the err function parameter.
  - Use camelCase for variables and functions.
  - Use PascalCase for React components, interfaces, and types.
  - Define TypeScript interfaces for component props instead of using prop-types.
  - Use type inference where possible, but be explicit for public APIs.

  Naming Conventions
  - Use lowercase with dashes for directories (e.g., components/photo-gallery).
  - Use default exports for components (e.g., `export default function ComponentName`).
  - Use named exports for utilities, hooks, and types.

  React 19 Best Practices
  - Use functional components with TypeScript interfaces for type checking.
  - Use function declarations or arrow functions for component definitions.
  - Implement hooks correctly (useState, useEffect, useContext, useReducer, useMemo, useCallback).
  - Follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions).
  - Create custom hooks to extract reusable component logic (use the `use` prefix).
  - Use React.memo() for component memoization when appropriate.
  - Implement useCallback for memoizing functions passed as props.
  - Use useMemo for expensive computations.
  - Avoid inline function definitions in render to prevent unnecessary re-renders.
  - Prefer composition over inheritance.
  - Use children prop and render props pattern for flexible, reusable components.
  - Implement React.lazy() and Suspense for code splitting.
  - Use refs sparingly and mainly for DOM access.
  - Prefer controlled components over uncontrolled components.
  - Implement error boundaries to catch and handle errors gracefully.
  - Use cleanup functions in useEffect to prevent memory leaks.
  - Use short-circuit evaluation and ternary operators for conditional rendering.
  - Leverage React 19 features like Actions, useOptimistic, and useFormStatus.

  State Management
  - Use Zustand for global state management.
  - Lift state up when needed to share state between components.
  - Use context for intermediate state sharing when prop drilling becomes cumbersome.

  UI and Styling
  - Use Shadcn UI and Radix UI for component foundations.
  - Use Magic UI components for animations and interactive elements.
  - Implement responsive design with Tailwind CSS v4; use a mobile-first approach.
  - Use Tailwind CSS v4 with the new `@import "tailwindcss"` syntax in globals.css.
  - Use Tailwind utility classes for all styling needs.
  - Use the `cn()` utility function from `@/lib/utils` for conditional class names.
  - Leverage Tailwind's CSS variables for theming (defined in globals.css).
  - Use Framer Motion for complex animations and transitions.
  - Implement custom keyframes in globals.css when needed.
  - Use Tailwind's @layer utilities for custom utility classes.

  File Structure for Components
  - Organize components in the components directory:
    - `components/ui/` - Shadcn UI components
    - `components/magicui/` - Magic UI components
    - `components/sections/` - Page sections and feature components
  - Example structure:
    components/
      magicui/
        blur-fade.tsx
        shimmer-button.tsx
      sections/
        photo-gallery/
          index.tsx
      ui/
        globe.tsx

  Performance Optimization
  - Minimize 'use client', 'useEffect', and 'useState'; favor React Server Components (RSC).
  - Wrap client components in Suspense with fallback.
  - Use dynamic loading for non-critical components.
  - Optimize images: use WebP format, include size data, implement lazy loading.
  - Implement route-based code splitting in Next.js.
  - Tailwind CSS v4 automatically purges unused styles in production.
  - Use React Compiler (babel-plugin-react-compiler) for automatic optimizations.

  Forms and Validation
  - Use controlled components for form inputs.
  - Implement form validation (client-side and server-side).
  - Consider using libraries like react-hook-form for complex forms.
  - Use Zod or Joi for schema validation.

  Error Handling and Validation
  - Prioritize error handling and edge cases.
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Model expected errors as return values in Server Actions.

  Accessibility (a11y)
  - Use semantic HTML elements.
  - Implement proper ARIA attributes.
  - Ensure keyboard navigation support.


  Security
  - Sanitize user inputs to prevent XSS attacks.
  - Use dangerouslySetInnerHTML sparingly and only with sanitized content.

  Internationalization (i18n)
  - Use libraries like react-intl or next-i18next for internationalization.

  Key Conventions
  - Use 'nuqs' for URL search parameter state management when needed.
  - Optimize Web Vitals (LCP, CLS, FID, INP).
  - Limit 'use client':
    - Favor server components and Next.js SSR.
    - Use only for Web API access, interactivity, or animations in small components.
    - Avoid for data fetching or state management.
    - Add 'use client' directive at the top of files that need client-side features.
  - Use TypeScript path aliases (@/components, @/lib, @/hooks) as defined in tsconfig.json.
  - Use the `cn()` utility function for merging Tailwind classes conditionally.
  - Follow Next.js 16 App Router conventions for Data Fetching, Rendering, and Routing.
  - Use Magic UI components for enhanced UI animations and interactions.
  - Leverage Framer Motion for complex animation sequences.
    